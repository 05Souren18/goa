package goa

import (
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/signal"
	"sync"
	"syscall"

	"github.com/julienschmidt/httprouter"
	"github.com/tylerb/graceful"
	"golang.org/x/net/context"
	log "gopkg.in/inconshreveable/log15.v2"
)

type (
	// Application represents a goa application. At the basic level an application consists of
	// a set of controllers, each implementing a given resource actions. goagen generates
	// global functions - one per resource - that make it possible to mount the corresponding
	// controller onto an application. An application contains the middleware, logger and error
	// handler shared by all its controllers. Setting up an application might look like:
	//
	//	api := goa.New("my api")
	//	api.Use(SomeMiddleware())
	//	api.Use(SomeOtherMiddleware())
	//	rc := NewResourceController()
	//	app.MountResourceController(api, rc)
	//	api.Run(":80")
	//
	// where NewResourceController returns an object that implements the resource actions as
	// defined by the corresponding interface generated by goagen.
	Application struct {
		log.Logger                      // Application logger
		Name         string             // Application name
		ErrorHandler ErrorHandler       // Application error handler
		Middleware   []Middleware       // Middleware chain
		Router       *httprouter.Router // Application router

		interruptMutex sync.Mutex       // synchronization for interrupts
		interrupted    bool             // true if interrupted
		server         *graceful.Server // graceful shutdown server
	}

	// Handler defines the controller handler signatures.
	// Controller handlers accept a context and return an error.
	// The context provides typed access to the request and response state. It implements
	// the golang.org/x/net/context package Context interface so that handlers may define
	// deadlines and cancelation signals - see the Timeout middleware as an example.
	// If a controller handler returns an error then the application error handler is invoked
	// with the request context and the error. The error handler is responsible for writing the
	// HTTP response. See DefaultErrorHandler and TerseErrorHandler.
	Handler func(*Context) error

	// ErrorHandler defines the application error handler signature. The default error handler
	// is DefaultErrorHandler. Call SetErrorHandler to provide a custom error handler. See
	// TerseErrorHandler as an alternative error handler.
	ErrorHandler func(*Context, error)
)

var (
	// Log is the global logger from which other loggers (e.g. request specific loggers) are
	// derived. Configure it by setting its handler prior to calling New.
	// See https://godoc.org/github.com/inconshreveable/log15
	Log log.Logger

	// InterruptSignals is the list of signals that initiate graceful shutdown.
	// Note that only SIGINT is supported on Windows so this list should be
	// overridden by the caller when running on that platform.
	InterruptSignals = []os.Signal{
		os.Signal(syscall.SIGINT),
		os.Signal(syscall.SIGTERM),
		os.Signal(syscall.SIGQUIT)}
)

// Log to STDOUT by default
func init() {
	Log = log.New()
	Log.SetHandler(log.StdoutHandler)
}

// New instantiates an application with the given name.
func New(name string) *Application {
	return &Application{
		Logger:       Log.New("app", name),
		Name:         name,
		ErrorHandler: DefaultErrorHandler,
		Router:       httprouter.New(),
	}
}

// Use adds a middleware to the application middleware chain.
// See NewMiddleware for the list of possible types for middleware.
// goa comes with a set of commonly used middleware, see middleware.go.
func (app *Application) Use(middleware interface{}) {
	m, err := NewMiddleware(middleware)
	if err != nil {
		Fatal("invalid middleware", "middleware", middleware, "err", err)
	}
	app.Middleware = append(app.Middleware, m)
}

// SetErrorHandler defines an application wide error handler.
// The default error handler returns a 500 status code with the error message in the response body.
// TerseErrorHandler provides an alternative implementation that does not send the error message
// in the response body for internal errors (e.g. for production).
// Set it with SetErrorHandler(TerseErrorHandler).
func (app *Application) SetErrorHandler(handler ErrorHandler) {
	app.ErrorHandler = handler
}

// Run starts the HTTP server and sets up a listener on the given host/port.
// It logs an error and exits the process with status 1 if the server fails to
// start (e.g. if the listen port is busy).
func (app *Application) Run(addr string) {
	// prepare
	app.prepareToRun(addr)

	// we will trap interrupts here instead of allowing the graceful package to do
	// it for us. the graceful package has the odd behavior of stopping the
	// interrupt handler after first interrupt. this leads to the dreaded double-
	// tap because the lack of any viable custom handler means that golang's
	// default handler will kill the process on a second interrupt.
	interruptChannel := make(chan os.Signal, 1)
	signal.Notify(interruptChannel, InterruptSignals...)
	go app.waitForInterrupt(interruptChannel)

	// run in foreground
	app.runServer()
}

// RunInBackground starts the HTTP server and sets up a listener on the given
// host/port on a background go routine. The caller is responsible for trapping
// interrupts and/or calling Shutdown() to initiate graceful shutdown.
//
// A background server is useful for apps that do other things besides serving
// requests. An example is an adapter that primarily marshals requests and
// responses between various services and secondarily serves a statistics API.
func (app *Application) RunInBackground(addr string, waitGroup *sync.WaitGroup) {
	// prepare
	app.prepareToRun(addr)

	// run in background. add go routine to waitgroup for synchronization.
	waitGroup.Add(1)
	go func() {
		defer waitGroup.Done()
		go app.runServer()
	}()
}

// Initiates graceful shutdown of the running server once. Returns true on
// initial shutdown and false if already shutting down.
func (app *Application) Shutdown() bool {
	app.interruptMutex.Lock()
	defer app.interruptMutex.Unlock()
	if app.interrupted {
		return false
	}
	app.interrupted = true
	app.server.Stop(0)
	return true
}

// prepares for running either in foreground or background.
func (app *Application) prepareToRun(addr string) {
	// note the use of zero timeout (i.e. no forced shutdown timeout) so requests
	// can run as long as they want. there is usually a hard limit to when the
	// response must come back (e.g. the nginx timeout) before being abandoned so
	// the handler should implement some kind of internal timeout (e.g. the go
	// context deadline) instead of relying on a shutdown timeout.
	app.server = &graceful.Server{
		Timeout:          0,
		Server:           &http.Server{Addr: addr, Handler: app.Router},
		NoSignalHandling: true}
}

// runs the already setup graceful server, which blocks on current go routine.
func (app *Application) runServer() {
	app.Info("listen", "addr", app.server.Addr)
	if err := app.server.ListenAndServe(); err != nil {
		// there may be a final "accept" error after completion of graceful shutdown
		// which can be safely ignored here.
		if opErr, ok := err.(*net.OpError); !ok || (ok && opErr.Op != "accept") {
			Fatal("startup failed", "err", err)
		}
	}
}

// handles multiple interrupts with grace.
func (app *Application) waitForInterrupt(interrupts chan os.Signal) {
	for signal := range interrupts {
		if app.Shutdown() {
			app.Warn(fmt.Sprintf("Received %v. Initiating graceful shutdown...", signal))
		} else {
			app.Warn(fmt.Sprintf("Received %v. Already gracefully shutting down.", signal))
		}
	}
}

// ServeHTTP implements the http.Handler interface.
func (app *Application) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	app.Router.ServeHTTP(w, r)
}

// NewHTTPRouterHandle returns a httprouter handle from a goa handler. This handle initializes the
// request context by loading the request state, invokes the handler and in case of error invokes
// the application error handler.
// This function is intended for the controller generated code. User code should not have to call
// it directly.
func (app *Application) NewHTTPRouterHandle(resName, actName string, h Handler) httprouter.Handle {
	// Setup middleware outside of closure
	chain := app.Middleware
	ml := len(chain)
	middleware := func(ctx *Context) error {
		if err := h(ctx); err != nil {
			app.ErrorHandler(ctx, err)
		}
		return nil
	}
	for i := range chain {
		middleware = chain[ml-i-1](middleware)
	}
	logger := app.Logger.New("ctrl", resName, "action", actName)
	return func(w http.ResponseWriter, r *http.Request, p httprouter.Params) {
		// Collect URL and query string parameters
		params := make(map[string]string, len(p))
		for _, param := range p {
			params[param.Key] = param.Value
		}
		q := r.URL.Query()
		query := make(map[string][]string, len(q))
		for name, value := range q {
			query[name] = value
		}

		// Load body if any
		var payload interface{}
		var err error
		if r.ContentLength > 0 {
			decoder := json.NewDecoder(r.Body)
			err = decoder.Decode(&payload)
		}

		// Build context
		gctx, cancel := context.WithCancel(context.Background())
		defer cancel() // Signal completion of request to any child goroutine
		ctx := NewContext(gctx, r, w, params, query, payload)
		ctx.Logger = logger

		// Handle invalid payload
		handler := middleware
		if err != nil {
			handler = func(ctx *Context) error {
				ctx.Respond(400, []byte(fmt.Sprintf(`{"kind":"invalid request","msg":"invalid JSON: %s"}`, err)))
				return nil
			}
			for i := range chain {
				handler = chain[ml-i-1](handler)
			}
		}

		// Invoke middleware chain
		handler(ctx)

		// Make sure a response is sent back to client.
		if ctx.ResponseStatus() == 0 {
			app.ErrorHandler(ctx, fmt.Errorf("unhandled request"))
		}
	}
}

// DefaultErrorHandler returns a 400 response for request validation errors (instances of
// BadRequestError) and a 500 response for other errors. It writes the error message to the
// response body in both cases.
func DefaultErrorHandler(c *Context, e error) {
	status := 500
	if _, ok := e.(*BadRequestError); ok {
		c.Header().Set("Content-Type", "application/json")
		status = 400
	}
	if err := c.Respond(status, []byte(e.Error())); err != nil {
		Log.Error("failed to send default error handler response", "err", err)
	}
}

// TerseErrorHandler behaves like DefaultErrorHandler except that it does not set the response
// body for internal errors.
func TerseErrorHandler(c *Context, e error) {
	status := 500
	var body []byte
	if _, ok := e.(*BadRequestError); ok {
		c.Header().Set("Content-Type", "application/json")
		status = 400
		body = []byte(e.Error())
	}
	if err := c.Respond(status, body); err != nil {
		Log.Error("failed to send terse error handler response", "err", err)
	}
}

// Fatal logs a critical message and exits the process with status code 1.
// This function is meant to be used by initialization code to prevent the application from even
// starting up when something is obviously wrong.
// In particular this function should probably not be used when serving requests.
func Fatal(msg string, ctx ...interface{}) {
	log.Crit(msg, ctx...)
	os.Exit(1)
}
